
import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 
        
import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 

import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    



import binascii
import socket as syssock
import struct
import sys
import numpy as np
import time
import threading

# these functions are global to the class and
# define the UDP ports all messages are sent
# and received from
SYN=0x01
ACK=0x04
HEADER_FMT='!BBHQQL'
recaddr =0
sendaddr  =0
send_seqno=25
rec_seqno=65
max_packet=(63*1024)
LIST_OF_PACKETS=[]
filesize=0
byteswrite=""
sock=0
sock2=0
def init(UDPportTx,UDPportRx):   # initialize your UDP socket here 
    global recaddr
    global sendaddr

    sendaddr=('',int(UDPportTx))
    recaddr= ('',int(UDPportRx))

    pass 
class sock352Thread (threading.Thread):
    global global_socket
    
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = float(delay)
        
    def run(self):
        recvdata(self.delay)
        return 

def recvdata(delay):
    return

class packet:
    def __init__(self,version=0,flags=0, header_len=0, sequence_no=0, ack_no=0, payload_len=0,data=b'',timestamp=0.0):
        self.version=version
        self.flags=flags
        self.header_len=header_len
        self.sequence_no=sequence_no
        self.ack_no=ack_no
        self.payload_len=payload_len
        self.data=data
        self.timestamp = timestamp
        return
    def printInfo():
        print('Version: ' + str(self.version) + ' Flags: ' + str(self.flags) + ' HeaderLen: ' + (self.header_len))
        print('SEQNO: ' + str(self.sequence_no) + ' ACKNO: ' + str(self.ack_no) + ' PAYLOADLEN: ' + str(self.payload_len) + ' DATALEN: ' + str(self.data))

    def pack(self):
        if(self.data==None):
            len_data=0
        else:
            len_data=len(self.data)
        if(len_data == 0):
            packdata= struct.pack(HEADER_FMT,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len)
        else:
            formwdata= HEADER_FMT+ str(len_data) +'s'
            packdata=struct.pack(formwdata,self.version,self.flags,self.header_len,self.sequence_no,self.ack_no,self.payload_len,self.data)
        return packdata
    
    def unpack(self,bytesizes):
        len_data=(len(bytesizes)-struct.calcsize(HEADER_FMT))
        if (len_data >= 0):
            unpackformat= HEADER_FMT+ str(len_data) +'s'
            packinfo = struct.unpack(unpackformat,bytesizes)
            self.version=packinfo[0]
            self.flags=packinfo[1]
            self.header_len=packinfo[2]
            self.sequence_no=packinfo[3]
            self.ack_no=packinfo[4]
            self.payload_len=packinfo[5]
            self.data=packinfo[6]

        return

class socket:
    def __init__(self):  # fill in your code here 
        global sock
        global sock2
        sock=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        sock2=syssock.socket(syssock.AF_INET,syssock.SOCK_DGRAM)
        self.spacket=packet()
        self.rpacket=packet()

    def remainingpackets(self, packet):
            if(LIST_OF_PACKETS[0].sequence_no==packet.ack_no):
                LIST_OF_PACKETS.pop(0)
            return

    def bind(self,address):
        global sock
        sock.bind(sendaddr)
        print("Bound to address %s", sendaddr)
        return 

    def connect(self,address):  # fill in your code here 
        global send_seqno
        global rec_seqno
        global LIST_OF_PACKETS
        global recaddr
        global sendaddr
        global sock
        global sock2
        sock2.bind(sendaddr)
        sock.connect(recaddr)
        # Creates syn packet and sends to server
        self.spacket.flags=SYN
        self.spacket.sequence_no=send_seqno
        send_seqno += 1
        byteinfo=self.spacket.pack()
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print(LIST_OF_PACKETS[0].flags)
        sock2.sendto(byteinfo,recaddr)
        print(self.spacket.sequence_no)

        #Append to global list of packets for retrieval
        print(LIST_OF_PACKETS[0].flags)
        

        #Wait to receive packet from server
        lenbyte,address=sock2.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbyte)
        rec_seqno=self.rpacket.sequence_no + 1
        self.remainingpackets(self.rpacket)

        #Form response to the server
        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=send_seqno
        self.spacket.ack_no=rec_seqno
        self.spacket.payload_len=0
        self.spacket.data= ""


        #Send Response to the server
        sock2.sendto(self.spacket.pack(),recaddr)
        print("Connection Established")


        return 
    
    def listen(self,backlog):
        return

    def accept(self):
        global max_packet
        global send_seqno
        global rec_seqno
        global sendaddr
        global recaddr
        global sock
        global sock2
        #global LIST_OF_PACKETS

        #Recieve packet from client to establish connection

        lenbytes, sendaddr = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)

        #Assemble packet to ack client message
        rec_seqno=self.rpacket.sequence_no

        self.spacket.version=1
        self.spacket.flags=ACK
        self.spacket.header_len=struct.calcsize(HEADER_FMT)
        self.spacket.sequence_no=rec_seqno
        rec_seqno+= 1
        self.spacket.ack_no=send_seqno
        send_seqno += 1
        self.spacket.payload_len=0
        self.spacket.data= ""

        #Send packet back to client and append to global list
        sock.sendto(self.spacket.pack(),sendaddr)
        LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data))
        print("Ack sent back to client")

        #Recieve final ack from client 
        lenbytes,address = sock.recvfrom(max_packet)
        packet.unpack(self.rpacket,lenbytes)
        self.remainingpackets(self.rpacket)


        #Remove newest packet from waiting queue list

        print("Connection Established")
        
        return (self,sendaddr)
    
    def close(self):   # fill in your code here 
        sock.close()
        sock2.close()
        return 

    def send(self,buffer):
        global filesize
        if(len(buffer)==4):
            sock2.sendto(buffer,recaddr)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(buffer)
            print(fileLenPacked[0])
            filesize=fileLenPacked[0]
            bytessent=4
            return bytessent
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            #acklist=[0, 128976, 193464]
            a=[]
            print(struct.calcsize(HEADER_FMT))
            while(acklist != a):
                self.spacket.version=1
                self.spacket.flags=0
                self.spacket.header_len=struct.calcsize(HEADER_FMT)
                self.spacket.sequence_no=acklist[0]
                self.spacket.ack_no=0
                self.spacket.payload_len=0
                if(len(acklist)>1):
                    self.spacket.data= buffer[acklist[0]:acklist[0]+max_packet-struct.calcsize(HEADER_FMT)]
                else:
                    self.spacket.data=buffer[acklist[0]:]
                print(self.spacket.data)
                sock2.sendto(self.spacket.pack(),recaddr)
                acklist.pop(0)
                LIST_OF_PACKETS.append(packet(self.spacket.version,self.spacket.flags,self.spacket.header_len,self.spacket.sequence_no,self.spacket.ack_no,self.spacket.payload_len,self.spacket.data,time.time()))
                print("Packet sent")
                print(acklist)
            return len(buffer)
        bytessent = 0     # fill in your code here 
        return bytessent 

    def recv(self,nbytes):
        global filesize
        global byteswrite
        global sock
        global sock2
        if(nbytes==4):
            lenbytes, address= sock.recvfrom(max_packet)
            longPacker = struct.Struct("!L")
            fileLenPacked = longPacker.unpack(lenbytes)
            filesize=fileLenPacked[0]
            print(fileLenPacked[0])
            return lenbytes
        else:
            acklist=range(0,filesize,max_packet-struct.calcsize(HEADER_FMT))
            
            a=[]
            while(acklist != a):
                print(acklist)
                lenbytes, address= sock.recvfrom(max_packet)
                print("hello")
                
                packet.unpack(self.rpacket,lenbytes)
               # print(self.rpacket.version)
                print(self.rpacket.sequence_no)
               # print(self.rpacket.data)
                if(self.rpacket.sequence_no==acklist[0]):
                    acklist.pop(0)
                    rec_seqno=self.rpacket.sequence_no
                    byteswrite=byteswrite + self.rpacket.data

                    self.spacket.version=1
                    self.spacket.flags=ACK
                    self.spacket.header_len=struct.calcsize(HEADER_FMT)
                    self.spacket.sequence_no=rec_seqno
                    self.spacket.ack_no=rec_seqno+(max_packet-struct.calcsize(HEADER_FMT))
                    self.spacket.payload_len=0
                    self.spacket.data= b""
                    sock.sendto(self.spacket.pack(),sendaddr)
                    print("Ack sent back to client")
                    print(acklist)
                    print("New print \n\n\n")
                    print(byteswrite)


            return byteswrite
            ##lenbytes, address=self.sock.recvfrom(max_packet)
            #packet.unpack(self.rpacket,lenbytes)


        bytesreceived = 0     # fill in your code here
        return bytesreceived 


    




    





    


